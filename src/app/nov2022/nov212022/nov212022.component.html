<a href="/blog/nov-2022/architectural-design-patterns#main-wrapper" id="backto-top" aria-label="Back to Top" class="back-to-top">
    <i class="fa fa-angle-double-up"></i>
</a>
<!-- Preloader Start Here -->
<div id="preloader"></div>
<!-- Preloader End Here -->
<div id="main-wrapper" class="main-wrapper">
    <app-header-area-light></app-header-area-light>
    <app-bread-crumb-light [title]="'Architectural Design Patterns'"></app-bread-crumb-light>
    <section class="section-padding">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-lg-8">
                    <div class="single-blog">
                        <div class="single-blog-content">
                            <div class="post-thumbnail">
                                <img class="rounded img-fluid wow fadeInUp" src="/assets/images/blog/architectural-design-patterns.webp" alt="Architectural Design Patterns">
                            </div>
                            <div class="author">
                                <div class="author-thumb">
                                    <img class="img-thumbnail wow fadeInUp" src="assets/media/blog/author-1.webp" alt="Tyrone Showers">
                                </div>
                                <div class="info">
                                    <h6 class="author-name">Tyrone Showers</h6>
                                    <ul class="blog-meta list-unstyled">
                                        <li>Nov 21, 2022</li>
                                    </ul>
                                </div>
                            </div>
                            <h2> Introduction </h2>
                            <p> Architectural design patterns are a set of guidelines for building software systems. They often describe how to handle common problems in an object-oriented way and
                                provide solutions that can be reused repeatedly. </p>
                             <h2 class="text-capitalize"> Event Driven </h2>
                            <p> The Event-Driven design pattern is a design pattern that uses events to communicate between classes. This pattern is used when one function wants to inform another function
                                about something. The event-driven pattern has two major components: </p>
                            <ul>
                                <li> Event generator - A class instance that generates events and sends them to other objects. It can be any object; however, it is usually a data source representing
                                    some action associated with the user interface (UI). </li>
                                <li> Event listener - An object or method that listens for specific events generated by an event generator. This can be any method or member variable of your
                                    application's classes. </li>
                            </ul>
                             <h2 class="text-capitalize"> Master Slave </h2>
                            <p> The master-slave pattern is a good choice for systems that need to be highly available, scalable, and fault tolerant. </p>
                            <p> In this pattern, one component is designated as the "master," and all other components are "slaves." The master does most of the decision-making and data processing,
                                while the slaves only do what they're told. </p>
                             <h2 class="text-capitalize"> MVC </h2>
                            <p> Model View Controller (MVC) is a software design pattern used in <a target="_blank" href="https://www.amazon.com/b?_encoding=UTF8&tag=taliferro2023-20&linkCode=ur2&linkId=cb303e3e6bde4143072cb5efaabcc9b3&camp=1789&creative=9325&node=565098">computer</a> programming. It divides an application into three interconnected parts: the model, the view,
                                and the controller. </p>
                            <p> The model represents or contains all of your program's data and business logic, which may include information from a database or user-inputted data. The view is what
                                users see on their screens; it comprises all of your visual elements, including menus, windows, and buttons, as well as their layout on-screen via HTML markup or XAML
                                (WPF/Silverlight). The controller connects these two: when a user interacts with something that impacts how data should be presented (for example, clicking a button),
                                it communicates this back to the controller, which then instructs models to update themselves with new information from sources such as databases or web services if
                                necessary. </p>
                             <h2 class="text-capitalize"> Broker </h2>
                            <p> This pattern uses a message broker to decouple clients from servers. Clients send requests to the broker, which routes them to servers. The client needs to find out how
                                many servers there are and where they are located. Depending on load balancing and other factors, the same request might be routed to different servers. The important
                                thing is that the client sends a request, which is stored in memory or persistent storage by the broker until it receives an acknowledgment from one of its back-end
                                services (known as servers), at which point it removes the message from its queue. This pattern is helpful for applications that have many users. For example, a chat
                                application might use this pattern so that new messages can instantly be sent even if all of its back-end services aren't available yet because messages will only be
                                sent when an acknowledgment comes back from at least one service running somewhere else in your system architecture. </p>
                             <h2 class="text-capitalize"> Interpreter </h2>
                            <p> Interpreters help manage programs written in programming languages that are
                                not yet compiled, such as source code in various stages of development. Since they interpret each statement sequentially rather than collecting it into machine language
                                ahead of time, interpreters can run much more slowly than compiled code and take longer to start up. However, interpreters have some advantages: If you make changes to
                                your program, you can re-run it instantly by just refreshing the page/restarting the application/etc., whereas with compiled code you must wait until the compiler
                                finishes its work before getting new output from your program. Additionally, since an interpreter needs only one copy of your source code (which may be written in any
                                language), it can run on more platforms than a compiler would need to support â€” including ones without a complete operating system! </p>
                             <h2 class="text-capitalize"> Client Server </h2>
                            <p> Client Server is a software design pattern in which the client and the <a target="_blank" href="https://www.amazon.com/b?_encoding=UTF8&tag=taliferro2023-20&linkCode=ur2&linkId=3a64388bbe76b2957e6be89844c315e6&camp=1789&creative=9325&node=11036071">server</a> are separate processes. The <a target="_blank" href="https://www.amazon.com/b?_encoding=UTF8&tag=taliferro2023-20&linkCode=ur2&linkId=3a64388bbe76b2957e6be89844c315e6&camp=1789&creative=9325&node=11036071">server</a> program runs in a loop, waiting for requests from
                                clients and servicing them by reading, writing, or manipulating the needed data. The client-server model is one of many ways to distribute work across multiple
                                computers. It involves one or more <a target="_blank" href="https://www.amazon.com/b?_encoding=UTF8&tag=taliferro2023-20&linkCode=ur2&linkId=3a64388bbe76b2957e6be89844c315e6&camp=1789&creative=9325&node=11036071">server</a> programs that accept requests from clients, perform some processing on them (often for web pages), then pass the results on to
                                the requesting client. </p>
                             <h2 class="text-capitalize"> Layered </h2>
                            <p> Layering is a common way of organizing software and is one of the most effective ways to manage complexity. The idea is simple: depending on the needs of your
                                application, you can split it into different layers (or tiers). Each layer should have its concerns, meaning it should only manage a specific application part. For
                                example, some layers will be responsible for displaying data on a screen, while others might handle complex business logic or persistence. The idea behind layering is
                                an abstraction; each layer has its interface, so users don't need to know how things work under the hood. This separation also allows us to hide complexity to make our
                                applications easier to use and maintain over time. </p>
                             <h2 class="text-capitalize"> Strangler </h2>
                            <p> The Strangler pattern is used when the client is tightly bound to the old interface, and it is difficult to change the client code. The pattern allows
                                you to replace an existing object so that the client does not have to be changed. The new entity has all of its methods replaced by new ones so that it behaves exactly
                                like the original one but with some additional features or improvements. </p>
                            <h2> Conclusion </h2>
                            <p> I hope this article helped you understand the different architectural patterns available. Each pattern has its benefits and drawbacks, and choosing the right one
                                depends on your project's requirements. </p>
                            <app-tyrone-showers-bio></app-tyrone-showers-bio>
                            <div class="row wow fadeInUp">
                                <div class="col"><a href="/blog/oct-2022/e-commerce-scalability-strategy" aria-label="Previous"><i class="fa fa-chevron-left" aria-hidden="true"></i> Previous</a>
                                </div>
                                <div class="col text-end"><a href="/blog/nov-2022/best-practices-for-network-systems" aria-label="Next"> Next <i class="fa fa-chevron-right" aria-hidden="true"></i>
                                    </a></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <app-posts-history></app-posts-history>
                </div>
            </div>
        </div>
    </section>
    <!--=====================================-->
    <!--=     Call To Action Area Start     =-->
    <!--=====================================-->
    <!--=====================================-->
    <!--=        Footer Area Start       	=-->
    <!--=====================================-->
    <app-footer-area></app-footer-area>
    <!--=====================================-->
    <!--=       Offcanvas Menu Area       	=-->
    <!--=====================================-->
    <app-off-canvas-menu></app-off-canvas-menu>
</div>